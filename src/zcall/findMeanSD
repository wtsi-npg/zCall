#! /usr/bin/python


# Copyright (c) 2013 Genome Research Ltd. All rights reserved.
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# Publication of the zCall algorithm:
# Goldstein JI, Crenshaw A, Carey J, Grant GB, Maguire J, Fromer M, 
# O'Dushlaine C, Moran JL, Chambert K, Stevens C; Swedish Schizophrenia 
# Consortium; ARRA Autism Sequencing Consortium, Sklar P, Hultman CM, 
# Purcell S, McCarroll SA, Sullivan PF, Daly MJ, Neale BM. 
# zCall: a rare variant caller for array-based genotyping: Genetics and 
# population analysis. Bioinformatics. 2012 Oct 1;28(19):2543-2545. 
# Epub 2012 Jul 27. PubMed PMID: 22843986.


# zCall: A Rare Variant Caller for Array-based Genotyping
# Jackie Goldstein
# jigold@broadinstitute.org
# April 5th, 2012

import sys
from optparse import OptionParser
from EGT import *

### Parse Inputs from Command Line
parser = OptionParser()
parser.add_option("-E","--egt",type="string",dest="egt",action="store",help=".EGT file path")
(options, args) = parser.parse_args()

if options.egt == None:
    print "specify EGT file path with -E"
    sys.exit()


### Write header line
head = ["SNP", "meanX", "meanY", "sdX", "sdY", "nMinorHom", "nCommonHom"] 
print "\t".join(head) # Write header line

### Initialize EGT class
egt = EGT(options.egt)

## Iterate over each SNP in EGT object
numSNPs = egt.numCodes ## number of SNPs in EGT file
causes = ['CR', 'Min_cluster_size', 'MAF', 'HWE']
excluded = [0]*4
callRates = []

# by default, apply 'sanity check' filter to SNPs
exclude = set()
output = []
maxExclusion = 0.95

for i in range(numSNPs):

    # Get SNP Name
    snp = egt.names[i]
    
    # Get number of points in each genotype cluster
    nAA = egt.nAA[i]
    nAB = egt.nAB[i]
    nBB = egt.nBB[i]
    nTotal = nAA + nAB + nBB

    # Extract the mean and sd for each common allele homozygote clusters in the noise dimension
    meanXAA = egt.meanXAA[i]
    meanXBB = egt.meanXBB[i]
    devXAA = egt.devXAA[i]
    devXBB = egt.devXBB[i]

    meanYAA = egt.meanYAA[i]
    meanYBB = egt.meanYBB[i]
    devYAA = egt.devYAA[i]
    devYBB = egt.devYBB[i]

    if meanXAA >= meanYAA: ## AA is in the lower right quadrant
        meanY = meanYAA
        devY = devYAA
        meanX = meanXBB
        devX = devXBB

    elif meanXAA < meanYAA: ## AA is in the upper left quadrant; however, this should never be the case by definition X -> A, Y -> B
        meanY = meanYBB
        devY = devYBB
        meanX = meanXAA
        devX = devXAA

    if nAA >= nBB:
        out = [snp, meanX, meanY, devX, devY, nBB, nAA] # output array
    elif nBB > nAA:
        out = [snp, meanX, meanY, devX, devY, nAA, nBB] # output array
    out = [str(o) for o in out]
    output.append("\t".join(out))

    # apply sanity checks and flag for exclusion if appropriate

    # Calculate Missing Rate (ignore SNPs that have less than 99% call rate)
    cr =  float(nTotal) / float(egt.numPoints)
    callRates.append(cr)
    if cr < 0.99:
        exclude.add(i)
        continue

    # Make sure there are at least 10 points in each homozygote cluster
    if nAA < 10 or nBB < 10:
        exclude.add(i)
        continue
    
    # Calculate MAF
    if nAA > nBB:
        maf = (nAB + 2 * nBB) / float(2 * nTotal)
    elif nAA <= nBB:
        maf = (nAB + 2 * nAA) / float(2 * nTotal)

    # MAF check ( >5% MAF)
    if maf < 0.05:
        exclude.add(i)
        continue
    
    # Hardy-Weinberg Equilibrium Check (don't use site if p_hwe < 0.00001)
    chiCritical = 19.5 # p = 0.00001 for 1 DOF

    if nAA > nBB:
        p = 1.0 - maf
        q = maf        
        expAA = p**2 * nTotal
        expAB = 2 * p * q * nTotal
        expBB = q**2 * nTotal

    if nBB >= nAA:
        p = 1.0 - maf
        q = maf        
        expAA = q**2 * nTotal
        expAB = 2 * p * q * nTotal
        expBB = p**2 * nTotal
        
    chiSquare = ((nAA - expAA)**2 / float(expAA)) + ((nAB - expAB)**2 / float(expAB)) + ((nBB - expBB)**2 / float(expBB))
    if chiSquare > chiCritical:
        exclude.add(i)
        continue

excludeRate = len(exclude)/float(numSNPs)
if excludeRate <= maxExclusion:
    for i in range(numSNPs):
        if i not in exclude: print output[i]
else:
    msg = "Warning: findMeanSD exclusion rate of "+str(excludeRate)+\
        " exceeds maximum of "+str(maxExclusion)+"; omitting SNP filter.\n"
    sys.stderr.write(msg)
    for i in range(numSNPs):
        print output[i]
