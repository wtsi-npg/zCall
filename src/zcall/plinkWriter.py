#! /usr/bin/env python

# Copyright (c) 2013 Genome Research Ltd. All rights reserved.
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# Publication of the zCall algorithm:
# Goldstein JI, Crenshaw A, Carey J, Grant GB, Maguire J, Fromer M, 
# O'Dushlaine C, Moran JL, Chambert K, Stevens C; Swedish Schizophrenia 
# Consortium; ARRA Autism Sequencing Consortium, Sklar P, Hultman CM, 
# Purcell S, McCarroll SA, Sullivan PF, Daly MJ, Neale BM. 
# zCall: a rare variant caller for array-based genotyping: Genetics and 
# population analysis. Bioinformatics. 2012 Oct 1;28(19):2543-2545. 
# Epub 2012 Jul 27. PubMed PMID: 22843986.

# Author: Iain Bancarz, ib5@sanger.ac.uk


"""Process Plink format genotyping data

See http://pngu.mgh.harvard.edu/~purcell/plink/

Requires the plinktools package; see https://github.com/iainrb/plinktools
"""

import json, struct
from math import ceil
from sys import stderr
from BPM import *
from plink import PlinkHandler # requires plinktools in PYTHONPATH


class PlinkWriter(PlinkHandler):
    """Class to handle Plink format data"""

    def __init__(self, bpm):
        """Initialize with a BPM object"""
        self.bpm = bpm
        self.snpTotal = self.bpm.getTotalSNPs()
        self.sortMap = self.snpSortMap()

    def callsToBinary(self, calls, reorder=True):
        """Translate genotype calls for one sample to Plink binary

        4 genotype calls are packed into one byte of output
        Returns a list of struct.pack strings corresponding to output bytes

        Overrides method in parent class, adds reorder functionality"""
        if len(calls) != self.snpTotal:
            msg = "Number of calls %s is not equal to SNP total %s" % \
                (len(calls), self.snpTotal)
            raise ValueError(msg)
        if reorder:
            sortedCalls = [None]*self.snpTotal
            i = 0
            while i < self.snpTotal:
                sortedCalls[self.sortMap[i]] = calls[i] 
                i += 1
            calls = sortedCalls
        if self.snpTotal % 4 != 0:
            # if not an integer number of bytes, pad with no calls
            calls.extend([0]*(4 - self.snpTotal % 4)) 
        output = [0]*(int(ceil(self.snpTotal/4.0)))
        i = 0
        while i < self.snpTotal:
            byte = struct.pack('B', self.callsToByte(calls[i:i+4]))
            j = i / 4
            try:
                output[j] = byte
            except IndexError:
                stderr.write("Failed to record byte at SNP index "+str(i)+"\n")
                raise
            i += 4
        return output

    def getSampleFields(self, sample):
        """Get 6 sample metadata fields for .fam or .ped file

        Fields are:
        - Family ID
        - Individual ID
        - Paternal ID
        - Maternal ID
        - Sex (1=male; 2=female; other=unknown)
        - Phenotype
        Conventionally, set family/individual IDs to sample URI
        Set gender code if known, otherwise default to -9
        Other values set to -9 as placeholder"""
        fields = ['-9']*6
        fields[0] = sample['uri']
        fields[1] = sample['uri']
        try: fields[4] = str(sample['gender_code'])
        except KeyError: pass
        return fields

    def numericChromosomes(self, chroms):
        """Convert to numeric chromosome IDs used by Plink"""
        for i in range(len(chroms)):
            if chroms[i]=='X': chroms[i] = 23
            elif chroms[i]=='Y': chroms[i] = 24
            elif chroms[i]=='XY': chroms[i] = 25
            elif chroms[i]=='MT': chroms[i] = 26
            else: chroms[i] = int(chroms[i])
        return chroms

    def snpSortMap(self):
        """Sort snps into (chromosome, position) order

        Ensures compatibility with sorted .bim files generated by Plink
        Return a map from original position to sorted position"""
        chroms = self.numericChromosomes(self.bpm.getChromosomes())
        pos = self.bpm.getPositions()
        coords = [None]*self.snpTotal
        for i in range(self.snpTotal):
            coords[i] = (chroms[i], int(pos[i]), i)
        coords.sort()
        sortMap = {}
        for i in range(self.snpTotal):
            [chrom, pos, orig] = coords[i]
            sortMap[orig] = i
        return sortMap

    def writeBed(self, binaryCalls, outPath, verbose=False):
        """Write output for one or more samples in Plink .bed format

        Input: List of call bytes, and output path
        Output file:  First 2 bytes are Plink magic number
        3rd byte is flag for an individual-major file
        Subsequent bytes represent genotype calls
        """
        header = [0b01101100, 0b00011011, 0b00000000]
        output = []
        for byte in header: output.append(struct.pack('B', byte))
        output.extend(binaryCalls)
        out = open(outPath, 'w')
        for byte in output: out.write(byte)
        out.close()
        if verbose: print len(output), "bytes written."

    def writeBim(self, outPath):
        """Write a Plink .bim file to accompany .bed output

        Similar to Plink .map format, except:
        - 2 additional columns for allele names (use A and B as dummy values)
        - Entries are *sorted* into (chromosome, position) order
        - Chromosomes are given numeric codes (including for X, Y, etc.)

        Use "while" instead of "for range" for greater efficiency
        """
        unsorted = [None]*self.snpTotal
        i = 0
        while i < self.snpTotal:
             snp = self.bpm.names[i]
             chr = self.bpm.chr[i]
             pos = self.bpm.pos[i]
             alleleA = self.bpm.A[i]
             alleleB = self.bpm.B[i]
             out = [chr, snp, "0", pos, alleleA, alleleB]
             unsorted[i] = out
             i += 1
        # sort manifest entries
        out = [None]*self.snpTotal
        i = 0
        while i < self.snpTotal:
            out[self.sortMap[i]] = unsorted[i]
            i += 1
        # write to file
        outFile = open(outPath, 'w')
        i = 0
        while i < self.snpTotal:
            words = []
            for item in out[i]: words.append(str(item))
            outFile.write("\t".join(words)+"\n")
            i += 1
        outFile.close()

    def writeFam(self, sampleJson, outPath):
        """Write a Plink .fam file to accompany .bed output"""
        samples = json.loads(open(sampleJson).read())
        outLines = []
        for sample in samples:
            outLines.append(' '.join(self.getSampleFields(sample))+"\n")
        outFile = open(outPath, 'w')
        outFile.write("".join(outLines))
        outFile.close()

    def writeMap(self, outPath):
        """Write Plink .map format file"""
        outLines = []
        for i in range(self.snpTotal):
            snp = self.bpm.names[i]
            chr = self.bpm.chr[i]
            pos = self.bpm.pos[i]
            out = [str(chr), str(snp), "0", str(pos)]
            outLines.append("\t".join(out)+"\n")
        outFile = open(outPath, 'w')
        outFile.write("".join(outLines))
        outFile.close()

    def writePed(self, calls, sampleJson, outPath):
        """Write Plink .ped format file.

        Each line represents one sample.
        First 6 fields are same as for .fam file, see writeFam() method.  
        Subsequent fields are allele pairs, eg. 'G C' or 'A B'. 
        If manifestNames==True then get allele symbols from manifest,
        otherwise use A and B respectively for major and minor alleles."""
        samples = json.loads(open(sampleJson).read())
        outLines = []
        if len(calls) % self.snpTotal !=0:
            msg = "Number of calls %s is not a multiple of SNP total %s" % \
                (len(calls), self.snpTotal)
            raise ValueError(msg)
        for i in range(len(samples)):
            fields = self.getSampleFields(samples[i])
            start = i * self.snpTotal
            for j in range(self.snpTotal):
                alleleA = self.bpm.A[j]
                alleleB = self.bpm.B[j]
                call = calls[start+j]
                if call == 1: symbol = alleleA+' '+alleleA
                elif call == 2: symbol = alleleA+' '+alleleB
                elif call == 3: symbol = alleleB+' '+alleleB
                else: symbol = "0 0"
                fields.append(symbol)
            outLines.append("\t".join(fields)+"\n")
        outFile = open(outPath, 'w')
        outFile.write("".join(outLines))
        outFile.close()
